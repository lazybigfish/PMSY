# 任务列表默认排序需求文档

## 需求时间
2026-02-12

## 需求描述
任务列表的默认排序是按照优先级，然后按照时间快到期优先排上面。

## 排序规则

### 第一优先级：优先级（降序）
优先级从高到低排序：
1. `urgent` - 紧急（最高）
2. `high` - 高
3. `medium` - 中
4. `low` - 低（最低）

### 第二优先级：截止日期（升序）
在同一优先级内，按截止日期升序排列（快到期的排前面）：
- 截止日期早的任务排在前面
- 没有截止日期的任务排在最后

## 排序示例

假设有以下任务：

| 任务 | 优先级 | 截止日期 |
|------|--------|----------|
| 任务A | high | 2026-02-15 |
| 任务B | urgent | 2026-02-20 |
| 任务C | high | 2026-02-10 |
| 任务D | medium | 2026-02-12 |
| 任务E | urgent | 2026-02-08 |
| 任务F | high | 无 |

排序后顺序：
1. 任务E (urgent, 2026-02-08) - 紧急且最临近
2. 任务B (urgent, 2026-02-20) - 紧急
3. 任务C (high, 2026-02-10) - 高优先级且临近
4. 任务A (high, 2026-02-15) - 高优先级
5. 任务F (high, 无) - 高优先级但无截止日期
6. 任务D (medium, 2026-02-12) - 中优先级

## 技术实现方案

### 优先级权重映射
```typescript
const priorityWeight: Record<string, number> = {
  urgent: 4,
  high: 3,
  medium: 2,
  low: 1
};
```

### 排序逻辑
```typescript
const sortedTasks = tasks.sort((a, b) => {
  // 第一优先级：按优先级权重降序
  const priorityDiff = priorityWeight[b.priority] - priorityWeight[a.priority];
  if (priorityDiff !== 0) return priorityDiff;

  // 第二优先级：按截止日期升序（快到期的在前）
  if (!a.due_date && !b.due_date) return 0;
  if (!a.due_date) return 1;  // a 无日期，排后面
  if (!b.due_date) return -1; // b 无日期，排后面

  return new Date(a.due_date).getTime() - new Date(b.due_date).getTime();
});
```

## 相关文件
- `src/pages/tasks/TaskList.tsx` - 任务列表主页面

## 验收标准
- [ ] 默认按优先级降序排列（紧急 > 高 > 中 > 低）
- [ ] 同一优先级内按截止日期升序排列（快到期的在前）
- [ ] 无截止日期的任务排在同优先级的最后
- [ ] 用户仍可通过表头点击切换其他排序方式
