# 全新部署脚本优化记录

## 日期
2026-02-12

## 背景
今天执行了 PMSY 系统的全新部署到服务器 43.136.69.250，在部署过程中遇到了一些问题，需要对部署脚本进行优化。

## 遇到的问题

### 问题 1: auth schema 初始化顺序问题

**现象**：
- auth 服务启动后不断重启
- 日志显示 `ERROR: schema "auth" does not exist`
- 或者 `ERROR: column "instance_id" does not exist`

**原因分析**：
1. 部署脚本先启动了所有 Docker 服务
2. gotrue (auth 服务) 启动时需要 auth schema 已存在
3. 但初始 schema 脚本中包含创建 auth schema 和表的语句
4. gotrue 尝试执行自己的 migrations 时，发现 auth schema 已存在但结构不符合预期，导致冲突

**解决方案**：
1. 在启动服务后、执行初始 schema 前，先手动创建 auth schema
2. 创建 auth schema 后，重启 auth 服务让其自动创建所需的表结构
3. 然后再执行初始 schema 脚本（使用 `IF NOT EXISTS` 避免冲突）

### 问题 2: _realtime schema 缺失

**现象**：
- realtime 服务启动失败
- 日志显示 `APP_NAME not available` 错误

**原因分析**：
- realtime 服务需要 `_realtime` schema 存在
- 部署脚本没有创建这个 schema

**解决方案**：
- 在数据库初始化步骤中，添加创建 `_realtime` schema 的命令

### 问题 3: create-admin-user.sh 脚本没有执行权限

**现象**：
- 执行 `sudo ./deploy/scripts/create-admin-user.sh` 时报错 `command not found`

**原因分析**：
- 脚本文件没有执行权限（权限为 `-rw-r--r--`）

**解决方案**：
- 在执行脚本前添加 `chmod +x deploy/scripts/create-admin-user.sh`

## 脚本优化内容

### 1. 在线部署模式优化

修改了 `deploy/fresh-install/deploy.sh` 中的服务器端部署脚本：

**原逻辑**：
```bash
echo "   [服务器] 初始化数据库..."
echo "     步骤 1/4: 创建 Supabase 角色..."
[ -f "deploy/scripts/init-supabase-roles.sql" ] && sudo docker-compose exec -T db psql -U postgres < deploy/scripts/init-supabase-roles.sql 2>/dev/null || echo "     警告: 角色初始化脚本执行失败"

echo "     步骤 2/4: 执行数据库初始化脚本..."
[ -f "deploy/scripts/init-supabase-db.sh" ] && sudo ./deploy/scripts/init-supabase-db.sh 2>/dev/null || true
[ -f "supabase/volumes/db/init/00-initial-schema.sql" ] && sudo docker-compose exec -T db psql -U postgres < supabase/volumes/db/init/00-initial-schema.sql 2>/dev/null || echo "     警告: 数据库架构初始化失败"

# ... 迁移和执行脚本
```

**优化后逻辑**：
```bash
echo "   [服务器] 初始化数据库..."

echo "     步骤 1/5: 创建 Supabase 角色..."
[ -f "deploy/scripts/init-supabase-roles.sql" ] && sudo docker-compose exec -T db psql -U postgres < deploy/scripts/init-supabase-roles.sql 2>/dev/null || echo "     警告: 角色初始化脚本执行失败"

echo "     步骤 2/5: 创建必要的 schema..."
# 创建 auth schema（gotrue 需要）
sudo docker-compose exec -T db psql -U postgres -c "CREATE SCHEMA IF NOT EXISTS auth;" 2>/dev/null || true
sudo docker-compose exec -T db psql -U postgres -c "GRANT ALL ON SCHEMA auth TO postgres;" 2>/dev/null || true
sudo docker-compose exec -T db psql -U postgres -c "GRANT ALL ON SCHEMA auth TO anon;" 2>/dev/null || true
sudo docker-compose exec -T db psql -U postgres -c "GRANT ALL ON SCHEMA auth TO authenticated;" 2>/dev/null || true
sudo docker-compose exec -T db psql -U postgres -c "GRANT ALL ON SCHEMA auth TO service_role;" 2>/dev/null || true

# 创建 _realtime schema（realtime 服务需要）
sudo docker-compose exec -T db psql -U postgres -c "CREATE SCHEMA IF NOT EXISTS _realtime;" 2>/dev/null || true
sudo docker-compose exec -T db psql -U postgres -c "GRANT ALL ON SCHEMA _realtime TO postgres;" 2>/dev/null || true

echo "     步骤 3/5: 重启 auth 服务以应用 schema..."
sudo docker-compose restart auth
sleep 5

echo "     步骤 4/5: 执行数据库初始化脚本..."
[ -f "deploy/scripts/init-supabase-db.sh" ] && sudo ./deploy/scripts/init-supabase-db.sh 2>/dev/null || true
[ -f "supabase/volumes/db/init/00-initial-schema.sql" ] && sudo docker-compose exec -T db psql -U postgres < supabase/volumes/db/init/00-initial-schema.sql 2>/dev/null || echo "     警告: 数据库架构初始化失败"

# ... 迁移和执行脚本（添加了 chmod +x）
[ -f "deploy/scripts/create-admin-user.sh" ] && chmod +x deploy/scripts/create-admin-user.sh && sudo ./deploy/scripts/create-admin-user.sh 2>/dev/null || true
```

### 2. 半离线部署模式优化

同样对半离线部署模式的数据库初始化部分进行了相同的优化。

## 关键改进点

1. **Schema 创建顺序**：
   - 先创建 Supabase 角色
   - 再创建 auth 和 _realtime schema
   - 重启 auth 服务让其自动初始化表结构
   - 最后执行初始 schema 和迁移

2. **权限设置**：
   - 为 auth schema 设置正确的权限（postgres, anon, authenticated, service_role）
   - 为 _realtime schema 设置权限

3. **脚本执行权限**：
   - 在执行 create-admin-user.sh 前添加 chmod +x

## 部署验证

优化后的部署流程：
1. ✅ 前端页面正常访问 http://43.136.69.250
2. ✅ Studio 管理界面正常 http://43.136.69.250:3000
3. ✅ API 服务正常 http://43.136.69.250:8000
4. ✅ 所有 Docker 服务正常运行

## 问题 4: 管理员用户创建失败

**现象**：
- 部署完成后无法使用 admin@pmsy.com / admin123 登录
- 数据库 auth.users 表中没有用户记录

**原因分析**：
- `create-admin-user.sh` 脚本需要交互式输入确认
- 部署脚本执行时无法交互，导致用户创建步骤被跳过
- 脚本没有执行权限

**解决方案**：
- 将管理员用户创建改为内联 SQL，直接在部署脚本中执行
- 不再依赖外部交互式脚本
- 创建用户后自动创建对应的 profile 记录

**修改内容**：
```bash
# 使用内联 SQL 创建管理员用户，避免依赖交互式脚本
ADMIN_EMAIL="admin@pmsy.com"
ADMIN_PASSWORD="admin123"
ADMIN_USERNAME="admin"

echo "       创建管理员用户: $ADMIN_EMAIL"
sudo docker-compose exec -T db psql -U postgres << EOF 2>/dev/null || echo "       警告: 管理员用户创建失败或已存在"
INSERT INTO auth.users (
    instance_id,
    id,
    aud,
    role,
    email,
    encrypted_password,
    email_confirmed_at,
    raw_app_meta_data,
    raw_user_meta_data,
    created_at,
    updated_at,
    is_sso_user
) VALUES (
    '00000000-0000-0000-0000-000000000000'::uuid,
    gen_random_uuid(),
    'authenticated',
    'authenticated',
    '$ADMIN_EMAIL',
    crypt('$ADMIN_PASSWORD', gen_salt('bf')),
    now(),
    '{"provider":"email","providers":["email"]}'::jsonb,
    '{"username":"$ADMIN_USERNAME","role":"admin"}'::jsonb,
    now(),
    now(),
    false
)
ON CONFLICT (email) WHERE is_sso_user = false DO NOTHING
RETURNING id;
EOF

# 创建用户 profile
echo "       创建用户 profile..."
sudo docker-compose exec -T db psql -U postgres << EOF 2>/dev/null || true
INSERT INTO public.profiles (id, username, full_name, role, email, created_at, updated_at)
SELECT 
    id,
    '$ADMIN_USERNAME',
    '系统管理员',
    'admin',
    '$ADMIN_EMAIL',
    now(),
    now()
FROM auth.users 
WHERE email = '$ADMIN_EMAIL'
ON CONFLICT (id) DO UPDATE SET 
    username = EXCLUDED.username,
    role = EXCLUDED.role,
    updated_at = now();
EOF
```

**重要发现**：直接插入 SQL 创建的用户无法通过 gotrue 认证，因为 gotrue 需要特定的密码哈希格式和其他内部字段。必须使用 Supabase Auth API 注册用户。

**最终解决方案**：
```bash
# 使用 Supabase Auth API 创建管理员用户
ADMIN_EMAIL="admin@pmsy.com"
ADMIN_PASSWORD="admin123"
ADMIN_USERNAME="admin"
ANON_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBtc3kiLCJyb2xlIjoiYW5vbiIsImlhdCI6MTc3MDg2MzY5NCwiZXhwIjoyMDg2MjIzNjk0fQ.4asR7SimAk1UwthtIo5LD22qee5hsGAoZqDcwoQaSCw"

# 使用 Auth API 注册用户
SIGNUP_RESULT=$(curl -s -X POST "http://localhost:8000/auth/v1/signup" \
  -H "apikey: $ANON_KEY" \
  -H "Content-Type: application/json" \
  -d "{\"email\": \"$ADMIN_EMAIL\", \"password\": \"$ADMIN_PASSWORD\", \"data\": {\"username\": \"$ADMIN_USERNAME\", \"role\": \"admin\"}}" 2>/dev/null || echo "")

if [[ "$SIGNUP_RESULT" == *"access_token"* ]]; then
    echo "✅ 管理员用户创建成功"
    
    # 更新用户 profile
    USER_ID=$(echo "$SIGNUP_RESULT" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
    if [ -n "$USER_ID" ]; then
        sudo docker-compose exec -T db psql -U postgres << EOF
        UPDATE public.profiles 
        SET username = '$ADMIN_USERNAME', 
            full_name = '系统管理员',
            role = 'admin'
        WHERE id = '$USER_ID';
EOF
    fi
fi
```

## 问题 5: search_path 配置问题

**现象**：
- auth 服务报错 `ERROR: relation "users" does not exist`
- gotrue 无法找到 auth.users 表

**原因分析**：
- postgres 用户的 search_path 没有包含 auth schema
- gotrue 查询时没有使用 schema 前缀

**解决方案**：
```sql
ALTER USER postgres SET search_path TO "$user", public, auth;
```

## 问题 6: 前端构建环境变量优先级问题

**现象**：
- 前端构建后，Supabase URL 配置错误
- 浏览器中前端请求发送到错误的云端 Supabase 地址
- 本地部署的 API 无法访问

**原因分析**：
- Vite 构建工具的环境变量优先级：`.env.local` > `.env` > `.env.[mode]`
- 项目中的 `.env.local` 配置了云端 Supabase URL（用于开发）
- 部署时复制了 `.env.production` 到 `.env`，但 `.env.local` 优先级更高
- 导致构建时使用了错误的配置

**解决方案**：
在构建前端前，备份并移除 `.env.local` 文件：
```bash
# 备份并移除 .env.local（Vite 会优先使用它）
if [ -f ".env.local" ]; then
    mv .env.local .env.local.backup
    echo "已备份 .env.local（避免覆盖生产配置）"
fi

npm run build

# 恢复 .env.local
if [ -f ".env.local.backup" ]; then
    mv .env.local.backup .env.local
    echo "已恢复 .env.local"
fi
```

**已更新的脚本**：
- `deploy/fresh-install/deploy.sh` - 全新部署脚本
- `deploy/update/deploy.sh` - 增量更新部署脚本
- `deploy/scripts/prepare-deploy.sh` - 部署包准备脚本

## 建议

1. **生产环境部署前**：
   - 确保 `.env.supabase` 中的密码已修改为强密码
   - 确保 `JWT_SECRET` 已修改为随机字符串
   - 确保 `API_EXTERNAL_URL` 和 `SITE_URL` 配置正确
   - 修改默认管理员密码（当前为 admin123）

2. **测试部署**：
   - 在正式部署前，建议先在测试环境验证部署脚本

3. **备份**：
   - 全新部署会清空所有数据，部署前请确保已备份重要数据

## 问题 7: PostgREST 数据库连接字符串中的特殊字符问题

**现象**：
- 登录成功但导航栏只显示"工作台"，其他模块缺失
- PostgREST 日志显示 `could not translate host name "2026@db" to address`
- API 查询返回 503 错误

**原因分析**：
- `.env` 文件中 `POSTGRES_PASSWORD=Willyou@2026` 包含 `@` 特殊字符
- PostgREST 使用 `PGRST_DB_URI` 连接数据库时，URL 中的 `@` 被解析为分隔符
- 导致数据库连接字符串解析错误，将 `2026@db` 误认为是主机名

**解决方案**：
在 `docker-compose.yml` 中硬编码 PostgREST 的数据库连接字符串，不使用环境变量：
```yaml
rest:
  environment:
    # 对密码中的 @ 进行 URL 编码为 %40
    PGRST_DB_URI: postgres://postgres:Willyou%402026@db:5432/postgres
```

**注意**：如果密码包含其他特殊字符（如 `#`、`:`、`/` 等），也需要进行 URL 编码。

## 问题 8: 用户角色权限配置问题

**现象**：
- 导航栏只显示"工作台"，其他模块缺失
- 数据库查询 `role_permissions` 表有数据，但前端不显示菜单

**原因分析**：
- 管理员用户的 `profiles.role` 字段值为 `user` 而不是 `admin`
- 前端根据用户的 role 查询 `role_permissions` 表获取权限
- `role_permissions` 表中只有 `admin` 角色的权限配置，没有 `user` 角色的权限

**解决方案**：
1. 更新管理员用户角色：
```sql
UPDATE profiles SET role = 'admin' WHERE email = 'admin@pmsy.com';
```

2. 为 user 角色添加基本权限（可选）：
```sql
INSERT INTO role_permissions (role_key, module_key) VALUES 
  ('user', 'dashboard'), ('user', 'projects'), ('user', 'tasks'), 
  ('user', 'files'), ('user', 'stakeholders');
```

## 问题 9: RLS 策略阻止 API 查询

**现象**：
- PostgREST 返回 `permission denied for table role_permissions`
- 数据库连接正常，但无法查询表数据

**原因分析**：
- `role_permissions` 表启用了 RLS (Row Level Security)
- 当前用户没有权限访问该表

**解决方案**：
1. 临时禁用 RLS（开发/测试环境）：
```sql
ALTER TABLE role_permissions DISABLE ROW LEVEL SECURITY;
```

2. 或者为表添加合适的 RLS 策略（生产环境）：
```sql
CREATE POLICY "Allow read for authenticated" ON role_permissions
  FOR SELECT TO authenticated USING (true);
```

## 问题 10: 浏览器缓存导致功能不更新

**现象**：
- 修复问题后，前端页面没有变化
- 需要多次强制刷新才能看到更新

**原因分析**：
- nginx 默认缓存静态资源（JS、CSS 文件）
- 浏览器缓存了旧的 index.html 和 JS 文件
- 即使后端已修复，前端仍使用旧代码

**解决方案**：
在 `nginx.conf` 中配置不缓存 index.html：
```nginx
location / {
    root /usr/share/nginx/html;
    index index.html;
    try_files $uri $uri/ /index.html;
    # 不缓存 index.html
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
}

# 带版本号的静态资源可以长期缓存
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    root /usr/share/nginx/html;
    if ($uri ~* "-[a-zA-Z0-9]+\.(js|css)$") {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

## 部署检查清单更新

在部署完成后，验证以下功能：

1. **基础服务**：
   - [ ] 前端页面正常访问 http://服务器IP
   - [ ] Studio 管理界面正常 http://服务器IP:3000
   - [ ] API 服务正常 http://服务器IP:8000
   - [ ] 所有 Docker 服务正常运行

2. **用户认证**：
   - [ ] 管理员用户能正常登录
   - [ ] 登录后导航栏显示所有模块（工作台、项目管理、任务中心等）
   - [ ] 用户角色正确（profiles.role = 'admin'）

3. **数据库**：
   - [ ] PostgREST 能正常查询数据
   - [ ] 没有 `permission denied` 错误
   - [ ] RLS 策略配置正确

4. **功能验证**：
   - [ ] 能创建项目
   - [ ] 能创建任务
   - [ ] 文件上传正常
   - [ ] 其他业务功能正常

## 相关文件

- `deploy/fresh-install/deploy.sh` - 全新部署脚本（已优化）
- `deploy/scripts/init-supabase-roles.sql` - Supabase 角色初始化脚本
- `supabase/volumes/db/init/00-initial-schema.sql` - 数据库初始 schema
- `deploy/scripts/create-admin-user.sh` - 管理员用户创建脚本（已弃用，改为 API 调用）
- `config/docker/docker-compose.yml` - Docker 配置（已修复 PostgREST 连接字符串）
- `config/nginx/nginx.conf` - Nginx 配置（已添加缓存控制）
