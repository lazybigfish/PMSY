# 供应商页面查询报错修复

## 问题描述

打开项目需求的供应商页面，控制台报错：

```
GET http://localhost:3001/rest/v1/project_suppliers?select=... 500 (Internal Server Error)
Error fetching data: {error: 'error', code: 'INTERNAL_ERROR', message: 'select *, "suppliers(*)"... - column "suppliers(*)" does not exist', statusCode: 500}
```

## 问题原因

代码中使用了 Supabase 风格的外键关联查询语法：

```typescript
.select(`
  *,
  suppliers(*),
  supplier_payments(amount)
`)
```

但当前项目的 API 层（`api.ts`）不支持这种外键关联查询语法，它只会把 `suppliers(*)` 当作普通列名处理，导致数据库报错 `column "suppliers(*)" does not exist`。

## 修复内容

### 修改文件

`src/pages/projects/tabs/Suppliers.tsx`

### 修改前

```typescript
const fetchData = async () => {
  setLoading(true);
  try {
    // Fetch Project Suppliers
    const { data: suppliersData, error: suppliersError } = await api.db
      .from('project_suppliers')
      .select(`
        *,
        suppliers(*),
        supplier_payments(amount)
      `)
      .eq('project_id', projectId);

    if (suppliersError) throw suppliersError;

    // 将返回数据中的字段映射为组件期望的格式
    const mappedSuppliersData = (suppliersData || []).map((item: any) => ({
      ...item,
      supplier: item.suppliers,
      payments: item.supplier_payments
    }));
    // ...
  }
};
```

### 修改后

```typescript
const fetchData = async () => {
  setLoading(true);
  try {
    // Fetch Project Suppliers
    const { data: suppliersData, error: suppliersError } = await api.db
      .from('project_suppliers')
      .select('*')
      .eq('project_id', projectId);

    if (suppliersError) throw suppliersError;

    // 获取供应商详细信息
    const supplierIds = (suppliersData || []).map((item: any) => item.supplier_id).filter(Boolean);
    let suppliersMap: Record<string, any> = {};
    if (supplierIds.length > 0) {
      const { data: suppliersInfo } = await api.db
        .from('suppliers')
        .select('*')
        .in('id', supplierIds);
      suppliersMap = (suppliersInfo || []).reduce((acc: any, s: any) => {
        acc[s.id] = s;
        return acc;
      }, {});
    }

    // 获取付款信息
    const projectSupplierIds = (suppliersData || []).map((item: any) => item.id);
    let paymentsMap: Record<string, any[]> = {};
    if (projectSupplierIds.length > 0) {
      const { data: paymentsData } = await api.db
        .from('supplier_payments')
        .select('*')
        .in('project_supplier_id', projectSupplierIds);
      paymentsMap = (paymentsData || []).reduce((acc: any, p: any) => {
        if (!acc[p.project_supplier_id]) acc[p.project_supplier_id] = [];
        acc[p.project_supplier_id].push(p);
        return acc;
      }, {});
    }

    // 将返回数据中的字段映射为组件期望的格式
    const mappedSuppliersData = (suppliersData || []).map((item: any) => ({
      ...item,
      supplier: suppliersMap[item.supplier_id] || null,
      payments: paymentsMap[item.id] || []
    }));
    // ...
  }
};
```

## 修复逻辑

改为手动分步查询：
1. 先查询 `project_suppliers` 表获取项目供应商关联数据
2. 根据 `supplier_id` 批量查询 `suppliers` 表获取供应商详细信息
3. 根据 `project_supplier_id` 批量查询 `supplier_payments` 表获取付款信息
4. 在内存中组装数据，映射为组件期望的格式

## 测试验证

1. 进入项目详情页的供应商页面
2. 页面应正常加载，不再出现 500 错误
3. 供应商列表应正确显示供应商信息和付款记录

## 修复时间

2026-02-16
