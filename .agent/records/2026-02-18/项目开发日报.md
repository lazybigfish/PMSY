# 项目开发日报 - 2026-02-18

## 今日完成工作

### 1. 系统主题适配组件开发

#### 创建主题化组件（9个）

| 组件名称 | 文件路径 | 功能说明 |
|---------|---------|---------|
| ThemedButton | `src/components/theme/ThemedButton.tsx` | 支持 primary/secondary/danger/ghost 四种变体 |
| ThemedCard | `src/components/theme/ThemedCard.tsx` | 支持 default/elevated/glass 三种变体 |
| ThemedInput | `src/components/theme/ThemedInput.tsx` | 支持 text/password/textarea 类型 |
| ThemedBadge | `src/components/theme/ThemedBadge.tsx` | 支持 primary/success/warning/error/info/secondary 六种状态 |
| ThemedNavItem | `src/components/theme/ThemedNav.tsx` | 导航菜单项组件 |
| ThemedLoading | `src/components/theme/ThemedLoading.tsx` | 包含 ThemedSpinner 和 ThemedSkeleton |
| ThemedAlert | `src/components/theme/ThemedAlert.tsx` | 支持 success/error/warning/info 四种类型 |
| ThemedModal | `src/components/theme/ThemedModal.tsx` | 包含基础 Modal 和 ConfirmModal，支持层叠淡化毛玻璃效果 |
| ThemedTable | `src/components/theme/ThemedTable.tsx` | 支持分页、加载状态、自定义列渲染 |

#### 三个主题配色方案

- **V1 经典版**：珊瑚橙主色调，商务风格
- **V2 科技版**：深邃紫+科技青，赛博朋克风格，支持暗黑模式
- **V3 时尚版**：天蓝色调，流体风格，毛玻璃效果

#### 页面迁移

- **登录页管理页面** (`LoginThemeConfig.tsx`)：全面使用主题化组件
  - ThemedCard 替换普通卡片
  - ThemedButton 替换普通按钮
  - ThemedInput 替换输入框
  - ThemedBadge 替换版本标签
  - ThemedAlert 替换消息提示
  - ThemedSpinner 替换加载动画

- **系统设置页面** (`SystemSettings.tsx`)：Tabs 组件主题化
  - 使用主题色作为激活 Tab 的背景色
  - 支持暗黑模式样式
  - 简化 Tabs 实现，使用自定义按钮组件

- **Dashboard 页面** (`Dashboard.tsx` 和 `StatsCards.tsx`)：
  - StatsCards 使用 ThemedCard 替换普通卡片
  - 统计卡片颜色根据主题动态变化
  - 按钮使用 ThemedButton 替换
  - 加载动画使用主题色
  - 支持暗黑模式样式

- **项目列表页面** (`ProjectList.tsx`)：
  - 统计卡片使用 ThemedCard 替换
  - 搜索框使用 ThemedInput 替换
  - 项目列表使用 ThemedTable 替换
  - 按钮使用 ThemedButton 替换
  - 删除确认使用 ThemedConfirmModal 替换
  - 状态徽章使用 ThemedBadge 替换
  - 支持暗黑模式样式
  - 阶段颜色根据主题动态变化
  - **修复布局问题**：调整"当前阶段"、"我的角色"和"操作"列的宽度和样式，使其在一行显示且大小协调

- **任务列表页面** (`TaskList.tsx`)：
  - 页面头部使用 ThemedButton 替换
  - 加载动画使用主题色
  - 8个统计卡片全部使用 ThemedCard 替换
  - 趋势图使用主题色渐变
  - 任务表格头部使用 ThemedCard 替换
  - 支持暗黑模式样式

- **论坛页面** (`ForumTab.tsx`)：
  - 加载动画使用主题色
  - 支持暗黑模式样式

- **项目创建页面** (`ProjectCreate.tsx`)：
  - 使用 ThemedModal 弹窗组件替代浏览器 alert
  - 错误提示使用主题化弹窗显示
  - 支持暗黑模式样式

#### 后端 API 改进

- **项目创建查重** (`api-new/src/routes/projects.ts`)：
  - 添加项目名称查重逻辑
  - 如果项目名称已存在，返回友好的错误提示
  - 错误信息：`项目名称「xxx」已存在，请使用其他名称`

#### 弹窗组件样式优化

- **遮罩层效果**：使用 `radial-gradient` 实现层叠淡化毛玻璃效果
  - 以弹窗为中心，从内到外透明度逐渐降低
  - 最外层完全透明，不会遮挡整个页面
  - 各主题有不同的透明度配置

### 2. 文件修改清单

| 文件 | 修改内容 |
|-----|---------|
| `src/components/theme/ThemedButton.tsx` | 创建主题化按钮组件 |
| `src/components/theme/ThemedCard.tsx` | 创建主题化卡片组件 |
| `src/components/theme/ThemedInput.tsx` | 创建主题化输入框组件（支持 textarea） |
| `src/components/theme/ThemedBadge.tsx` | 创建主题化徽章组件 |
| `src/components/theme/ThemedNav.tsx` | 创建主题化导航组件 |
| `src/components/theme/ThemedLoading.tsx` | 创建主题化加载组件 |
| `src/components/theme/ThemedAlert.tsx` | 创建主题化提示组件 |
| `src/components/theme/ThemedModal.tsx` | 创建主题化弹窗组件，优化遮罩层为层叠淡化效果 |
| `src/components/theme/ThemedTable.tsx` | 创建主题化表格组件 |
| `src/components/theme/index.ts` | 更新组件导出索引 |
| `src/pages/system/tabs/LoginThemeConfig.tsx` | 迁移使用主题化组件 |
| `src/pages/system/SystemSettings.tsx` | 简化 Tabs 实现，支持主题色 |
| `src/pages/Dashboard.tsx` | 迁移按钮和加载动画 |
| `src/pages/dashboard/components/StatsCards.tsx` | 迁移使用 ThemedCard |
| `src/pages/projects/ProjectList.tsx` | 全面迁移使用主题化组件，修复布局问题 |
| `src/pages/projects/ProjectCreate.tsx` | 使用 ThemedModal 替代 alert，优化错误提示 |
| `src/pages/tasks/TaskList.tsx` | 全面迁移使用主题化组件 |
| `src/pages/water/ForumTab.tsx` | 迁移加载动画使用主题色 |
| `api-new/src/routes/projects.ts` | 添加项目创建查重逻辑 |

### 3. 开发环境验证

- ✅ TypeScript 类型检查通过
- ✅ 开发服务器启动成功 (http://localhost:5173/)
- ✅ 所有主题化组件已导出

## 主题系统架构

### 核心文件

- `src/types/theme.ts` - 主题类型定义
- `src/themes/v1.ts` - V1 主题配置
- `src/themes/v2.ts` - V2 主题配置
- `src/themes/v3.ts` - V3 主题配置
- `src/context/ThemeContext.tsx` - 主题上下文（支持 CSS 变量注入）

### 使用方式

```typescript
// 切换主题
import { useTheme } from './context/ThemeContext';
const { setTheme } = useTheme();
setTheme('v2');

// 使用主题化组件
import { ThemedButton, ThemedCard, ThemedInput } from './components/theme';

// 获取主题配置
const { themeConfig, isDark } = useTheme();
const { colors, gradients, shadows } = themeConfig;
```

## 遇到的问题与解决方案

### 1. ThemedNav 组件类型错误
**问题**：`gradients` 属性不存在于 `colors` 类型上
**解决**：从 `themeConfig` 直接解构 `gradients`

### 2. ThemedAlert 返回类型不明确
**问题**：`getAlertStyles` 返回类型不统一
**解决**：明确指定返回类型为 `{ background: string; color: string; borderColor: string; border: string }`

### 3. ThemedCard 缺少属性
**问题**：使用时需要传递 `onClick` 和 `style` 属性
**解决**：在接口定义中添加这两个属性

### 4. Radix UI Tabs 类型复杂
**问题**：Radix UI 的 Tabs 组件使用 render props 模式，类型复杂
**解决**：简化实现，使用自定义按钮组件替代

### 5. StatsCards groupHover 样式问题
**问题**：Tailwind 的 group-hover 与动态颜色值不兼容
**解决**：使用 Tailwind 的任意值语法 `group-hover:text-[${color}]`

### 6. ThemedTable columns render 函数签名
**问题**：render 函数期望接收 `(record: T) => ReactNode`，但传入的是 `(_: any, index: number)`
**解决**：修改 render 函数签名，从 record 中获取 index

### 7. 项目列表页面布局问题
**问题**："当前阶段"、"我的角色"和"操作"列显示不协调，文字跨行
**解决**：
- 调整各列宽度：当前阶段 100px、我的角色 90px、操作 110px
- 添加 `whitespace-nowrap` 防止文字换行
- 使用 flex 布局居中显示
- 详情按钮使用主题色，更美观紧凑

### 8. 项目创建查重提示问题
**问题**：查重失败时弹出 HTTP 500 错误，使用浏览器默认 alert
**解决**：
- 后端 API 添加查重逻辑，返回友好的错误信息
- 前端使用 ThemedModal 弹窗组件替代 alert
- 优化错误提示样式，使用红色图标和主题化样式

### 9. 弹窗遮罩层效果
**问题**：用户要求不使用全覆盖毛玻璃，使用层叠淡化效果
**解决**：
- 使用 `radial-gradient` 实现以弹窗为中心的渐变遮罩
- 从内到外：`rgba(0,0,0,x)` -> `rgba(0,0,0,y)` -> `transparent`
- 各主题配置不同的透明度值

### 3. 部署脚本更新

#### 数据库初始化文件更新

| 文件 | 更新内容 |
|-----|---------|
| `api-new/database/init/001_create_profiles.sql` | 添加 `force_password_change` 字段（合并自 migration 026） |
| `api-new/database/init/002_create_projects.sql` | 添加 `idx_projects_name` 索引（用于项目查重） |
| `api-new/database/init/021_create_system_settings.sql` | 新增系统设置表，存储主题配置和登录页配置 |
| `api-new/database/init/999_complete_schema.sql` | 更新注释说明，包含 001-027 所有迁移 |
| `api-new/database/migrations/027_create_system_settings.sql` | 新增迁移文件，用于存量环境升级 |

#### 数据库变更详情

**profiles 表新增字段：**
```sql
force_password_change BOOLEAN DEFAULT false
```

**projects 表新增索引：**
```sql
CREATE INDEX IF NOT EXISTS idx_projects_name ON projects(name);
```

**新增 system_settings 表：**
```sql
CREATE TABLE IF NOT EXISTS system_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    key TEXT UNIQUE NOT NULL,
    value JSONB NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
```

**默认配置数据：**
- `theme_config` - 系统主题配置（主题版本、登录页样式）
- `login_page_config` - 登录页面显示配置

#### 部署脚本问题修复

**问题：** `update/deploy.sh` 执行数据库迁移时报错

**原因：** 
- `027_create_system_settings.sql` 使用了 `update_updated_at_column()` 函数
- 该函数在 `001_create_profiles.sql` 中定义，但存量环境可能未正确初始化

**修复方案：**
1. **更新 `migrate.sh`** - 在迁移开始前自动创建基础函数
2. **更新 `027_create_system_settings.sql`** - 添加函数定义确保兼容性
3. **更新 `021_create_system_settings.sql`** - 添加函数定义确保兼容性

**修复文件清单：**
| 文件 | 修复内容 |
|-----|---------|
| `api-new/database/migrate.sh` | 迁移前自动创建 `update_updated_at_column` 函数 |
| `api-new/database/migrations/027_create_system_settings.sql` | 添加函数定义，确保存量环境兼容 |
| `api-new/database/init/021_create_system_settings.sql` | 添加函数定义，确保全新部署兼容 |

#### 部署脚本输出优化

**问题：** `update/deploy.sh` 前后端构建输出不清晰，无法确认是否真正更新了代码

**优化内容：**
1. **添加构建进度提示** - 显示"开始构建前端（可能需要 30-60 秒）..."
2. **添加错误处理** - 构建失败时立即退出并显示错误信息
3. **添加构建结果统计** - 显示构建产物大小和文件数量

**优化后的输出示例：**
```
[3/7] 构建前端...
   已保存原始 .env 配置
   使用 config/env/.env.production 进行构建
   开始构建前端（可能需要 30-60 秒）...
   已恢复原始 .env 配置
   ✅ 前端构建完成
   构建产物大小: 15M
   文件数量: 42

[4/7] 构建后端 API...
   编译 TypeScript...
   ✅ 后端构建完成
   构建产物大小: 3.2M
   文件数量: 128
```

### 3. 服务器重置密码 404 错误分析

**问题现象：**
服务器环境（43.136.69.250）重置用户密码时出现 404 错误：
```
POST http://43.136.69.250/auth/v1/admin/users/fa0a10f8-5f3a-4a56-a1c2-a0cb8a29999e/reset-password 404 (Not Found)
{"error":"Not Found","code":"ROUTE_NOT_FOUND","message":"路由 GET /auth/v1/admin/users/.../reset-password 不存在","statusCode":404}
```

**问题分析：**
1. **后端代码已存在**：`api-new/src/routes/auth.ts` 第 352 行已定义 `POST /admin/users/:id/reset-password` 路由
2. **前端代码正确**：`src/services/adminUserService.ts` 第 101-112 行使用 POST 方法调用
3. **错误根源**：服务器上的后端代码版本过旧，未包含重置密码接口

**解决方案：**
需要重新部署后端服务，确保服务器上的代码包含重置密码功能。

**部署步骤：**
```bash
# 1. 执行更新部署脚本
./deploy/update/deploy.sh

# 2. 验证部署结果
curl -X POST http://43.136.69.250/api/auth/v1/admin/users/{userId}/reset-password \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"mode":"random"}'
```

**相关文档：**
- 详细修复记录：`密码重置功能修复记录.md`

---

### 4. 登录页主题配置跨浏览器同步修复

**问题现象：**
用户在浏览器 A 中设置登录页主题为 V2/V3，换用浏览器 B 打开登录页时，主题恢复为默认的 V1 版本。

**问题分析：**
1. **根本原因**：登录页只从 `localStorage` 读取主题配置
2. **localStorage 特性**：浏览器本地存储，不会跨浏览器同步
3. **结果**：每个浏览器都有独立的主题配置，无法全局统一

**解决方案：**
1. **后端**：创建公开 API 端点 `GET /health/public-config`，无需认证即可获取系统配置
2. **前端**：修改 `Login.tsx`，加载时先从后端 API 获取最新主题配置，再回退到 localStorage

**修改文件：**
- `api-new/src/routes/health.ts`：添加公开配置接口
- `src/pages/Login.tsx`：添加 API 调用逻辑

**代码变更：**
```typescript
// 后端：公开配置接口
router.get('/public-config', async (req, res) => {
  const themeConfig = await db('system_configs')
    .where('key', 'login_page_theme')
    .select('value')
    .first();
  // ... 返回配置
});

// 前端：加载主题配置
const loadThemeConfig = async () => {
  // 1. 先从本地存储读取（快速响应）
  const cachedTheme = localStorage.getItem('login_page_theme');
  
  // 2. 从后端公开 API 获取最新配置
  const response = await fetch(`${API_BASE_URL}/health/public-config`);
  if (response.ok) {
    const data = await response.json();
    setConfig({ theme: data.login_page_theme, ... });
    localStorage.setItem('login_page_theme', data.login_page_theme);
  }
};
```

**验证方式：**
1. 在浏览器 A 中设置主题为 V2/V3
2. 换用浏览器 B 打开登录页
3. 确认显示的是 V2/V3 主题，而非默认 V1

---

### 5. 登录页主题配置保存问题修复（补充修复）

**问题现象：**
用户设置主题后，数据库中没有保存记录，导致跨浏览器同步仍然失败。

**问题分析：**
1. **根本原因**：前端使用 `update` 操作，但数据库中可能没有 `login_page_theme` 记录
2. **结果**：更新操作对不存在的记录无效，配置无法持久化到数据库

**解决方案：**
1. **后端**：新增 `POST /health/admin/config` API，支持插入或更新（upsert）操作
2. **前端**：修改 `LoginThemeConfig.tsx`，使用新的 API 保存配置

**修改文件：**
- `api-new/src/routes/health.ts`：添加 admin/config 接口
- `src/pages/system/tabs/LoginThemeConfig.tsx`：使用新 API 保存配置

**代码变更：**
```typescript
// 后端：支持 upsert 的配置更新接口
router.post('/admin/config', requireAuth, requireAdmin, async (req, res) => {
  const { key, value } = req.body;
  const existing = await db('system_configs').where('key', key).first();
  
  if (existing) {
    await db('system_configs').where('key', key).update({ value, updated_at: ... });
  } else {
    await db('system_configs').insert({ key, value, created_at: ..., updated_at: ... });
  }
});

// 前端：使用新 API 保存主题
await fetch(`${API_BASE_URL}/health/admin/config`, {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
  body: JSON.stringify({ key: 'login_page_theme', value: themeId }),
});
```

**部署说明：**
需要重新编译并重启后端服务使新 API 生效。

---

### 6. 开发环境一键脚本优化

**问题现象：**
开发环境的三个一键脚本（start-dev.sh、stop-dev.sh、restart-dev.sh）只是关停服务，没有编译步骤，导致代码变更后重启服务不会生效。

**优化内容：**

1. **start-dev.sh**：
   - 添加后端编译步骤（`npm run build`）
   - 添加依赖检查（自动安装缺失的依赖）
   - 如果端口被占用，自动停止并重启服务
   - 使用 `npm start` 替代 `npm run dev`，确保运行编译后的代码

2. **restart-dev.sh**：
   - 添加明确的编译步骤（步骤 2/3）
   - 优化输出信息和颜色

3. **stop-dev.sh**：
   - 保持不变（功能已完善）

**修改文件：**
- `deploy/dev-scripts/start-dev.sh`
- `deploy/dev-scripts/restart-dev.sh`

**使用方式：**
```bash
# 启动开发环境（自动编译并启动）
./deploy/dev-scripts/start-dev.sh

# 重启开发环境（停止→编译→启动）
./deploy/dev-scripts/restart-dev.sh

# 停止开发环境
./deploy/dev-scripts/stop-dev.sh
```

---

### 7. 角色权限迁移文件修复

**问题现象：**
每次执行更新部署脚本后，角色权限页面中配置好的模块权限被重置为默认值。

**问题分析：**
1. **根本原因**：迁移文件 `009_create_app_roles.sql` 每次执行都会插入默认权限
2. **虽然使用了 `ON CONFLICT DO NOTHING`**，但这只能防止重复插入，不能防止用户删除的权限被重新添加
3. **结果**：用户删除的默认权限在部署后会被重新插入，导致权限配置被重置

**解决方案：**
修改迁移文件，**只在 role_permissions 表为空时才插入默认权限**：

```sql
-- 只在 role_permissions 表为空时才插入默认权限
-- 避免每次部署时重置用户已配置的权限
DO $$
BEGIN
    -- 检查是否已有权限数据
    IF NOT EXISTS (SELECT 1 FROM role_permissions LIMIT 1) THEN
        -- 插入默认权限...
    END IF;
END $$;
```

**修改文件：**
- `api-new/database/migrations/009_create_app_roles.sql`
- `api-new/database/init/010_create_app_roles.sql`

**影响范围：**
- 新环境：首次部署时会插入默认权限
- 现有环境：已有权限数据不会被重置

---

### 8. 里程碑任务迁移文件修复

**问题现象：**
`003_create_milestones.sql` 迁移文件每次执行都会插入里程碑任务数据，导致重复数据。

**问题分析：**
1. **根本原因**：`milestone_tasks` 表没有唯一约束，每次运行迁移都会插入新数据
2. **结果**：多次部署后会产生大量重复的里程碑任务数据

**解决方案：**
修改迁移文件，只在 `milestone_tasks` 表为空时才插入默认任务数据：

```sql
-- 只在 milestone_tasks 表为空时插入，避免重复数据
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM milestone_tasks LIMIT 1) THEN
        -- 插入默认里程碑任务...
    END IF;
END $$;
```

**修改文件：**
- `api-new/database/migrations/003_create_milestones.sql`

---

### 9. 重置密码复制功能报错修复

**问题现象：**
服务器环境重置密码成功后，点击复制密码按钮时，控制台报错：
```
Uncaught TypeError: Cannot read properties of undefined (reading 'writeText')
```

**问题分析：**
1. **根本原因**：`navigator.clipboard` 在某些浏览器环境下可能为 `undefined`
2. **触发场景**：
   - HTTP 环境（非 HTTPS）
   - 页面在 iframe 中运行
   - 用户拒绝了剪贴板权限
   - 浏览器不支持 Clipboard API
3. **结果**：直接调用 `navigator.clipboard.writeText()` 导致报错

**解决方案：**
1. **添加存在性检查**：在使用前检查 `navigator.clipboard` 是否存在
2. **提供降级方案**：当 Clipboard API 不可用时，使用传统的 `document.execCommand('copy')` 方法
3. **添加错误处理**：捕获并记录复制失败的情况

**修改文件：**
- `src/pages/system/tabs/UserManagement/components/ResetPasswordModal.tsx`

**代码变更：**
```typescript
// 修复前
const handleCopy = () => {
  if (newPassword) {
    navigator.clipboard.writeText(newPassword);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  }
};

// 修复后
const handleCopy = async () => {
  if (!newPassword) return;

  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(newPassword);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } else {
      // 降级方案：使用传统的复制方法
      const textArea = document.createElement('textarea');
      textArea.value = newPassword;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        }
      } catch (err) {
        console.error('复制失败:', err);
      }

      document.body.removeChild(textArea);
    }
  } catch (error) {
    console.error('复制到剪贴板失败:', error);
  }
};
```

**验证方式：**
1. 重置用户密码
2. 点击复制密码按钮
3. 确认密码已成功复制到剪贴板
4. 检查控制台无报错信息

---

### 10. 相关方模块客户保存失败修复

**问题现象：**
在相关方模块中添加客户时，点击保存按钮后控制台报错：
```
POST http://localhost:3001/rest/v1/client_contacts 500 (Internal Server Error)
[API] Insert error to client_contacts: Error: The query is empty
```

**问题分析：**
1. **根本原因**：当用户没有填写任何联系人信息时，`validContacts` 数组为空
2. **错误触发**：代码尝试向 `client_contacts` 表插入一个空数组 `[]`
3. **Knex 行为**：Knex 在插入空数组时会抛出 "The query is empty" 错误
4. **代码位置**：`ClientFormPage.tsx` 第 155-168 行

**解决方案：**
在插入联系人之前，先检查 `validContacts` 数组是否为空，只有在有有效联系人时才执行插入操作。

**修改文件：**
- `src/pages/stakeholders/ClientFormPage.tsx`

**代码变更：**
```typescript
// 修复前
const contactsToInsert = validContacts.map((c, index) => ({
  client_id: clientId,
  name: c.name.trim(),
  phone: c.phone!.trim(),
  position: c.position?.trim() || null,
  email: c.email?.trim() || null,
  is_primary: index === 0
}));

const { error: contactsError } = await api.db
  .from('client_contacts')
  .insert(contactsToInsert);

if (contactsError) throw contactsError;

// 修复后
// 只有在有有效联系人时才插入
if (validContacts.length > 0) {
  const contactsToInsert = validContacts.map((c, index) => ({
    client_id: clientId,
    name: c.name.trim(),
    phone: c.phone!.trim(),
    position: c.position?.trim() || null,
    email: c.email?.trim() || null,
    is_primary: index === 0
  }));

  const { error: contactsError } = await api.db
    .from('client_contacts')
    .insert(contactsToInsert);

  if (contactsError) throw contactsError;
}
```

**验证方式：**
1. 进入相关方模块，点击新增客户
2. 只填写客户基本信息（名称、编码等），不填写联系人
3. 点击保存，确认保存成功
4. 再次测试填写联系人信息的情况，确认也能正常保存

---

### 11. 供应商保存字段不匹配修复

**问题现象：**
在服务器环境保存供应商时，控制台报错：
```
POST http://43.136.69.250/api/rest/v1/suppliers 500 (Internal Server Error)
[API] Insert error to suppliers: Error: insert into "suppliers" ("address", ...)
column "address" of relation "suppliers" does not exist
```

**问题分析：**
1. **根本原因**：前端代码尝试插入 `address` 和 `category` 字段，但数据库表中没有这些字段
2. **字段不匹配**：
   - 前端 `supplierService.ts` 定义了 `address` 和 `category` 字段
   - 数据库 `suppliers` 表缺少这两个字段
3. **结果**：SQL 插入语句执行失败

**解决方案：**
1. **创建迁移文件**：添加 `address` 和 `category` 字段到 `suppliers` 表
2. **更新初始化文件**：确保新环境创建表时包含这些字段

**修改文件：**
- `api-new/database/migrations/028_add_supplier_address_category.sql`（新增）
- `api-new/database/migrations/005_create_suppliers_and_risks.sql`
- `api-new/database/init/006_create_suppliers_and_risks.sql`

**代码变更：**
```sql
-- 为 suppliers 表添加 address 和 category 字段
ALTER TABLE suppliers
ADD COLUMN IF NOT EXISTS address TEXT;

ALTER TABLE suppliers
ADD COLUMN IF NOT EXISTS category TEXT;

-- 添加注释
COMMENT ON COLUMN suppliers.address IS '供应商地址';
COMMENT ON COLUMN suppliers.category IS '供应商类别';
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入供应商管理页面
3. 添加新供应商（填写地址和类别）
4. 确认保存成功，无报错

---

### 12. 客户保存字段不匹配修复（补充）

**问题现象：**
在服务器环境保存客户时，控制台报错：
```
POST http://43.136.69.250/api/rest/v1/clients 500 (Internal Server Error)
[API] Insert error to clients: Error: insert into "clients" ("code", "created_by", "location", "name", "status")
column "location" of relation "clients" does not exist
```

**问题分析：**
1. **根本原因**：前端代码使用 `location` 字段，但数据库表中没有这个字段
2. **字段不一致**：
   - 前端 `ClientFormPage.tsx` 使用 `location` 字段表示"地点"
   - 数据库 `clients` 表只有 `address` 字段，没有 `location` 字段
3. **结果**：SQL 插入语句执行失败

**解决方案：**
1. **创建迁移文件**：添加 `location` 字段到 `clients` 表
2. **更新初始化文件**：确保新环境创建表时包含 `location` 字段

**修改文件：**
- `api-new/database/migrations/029_add_client_location.sql`（新增）
- `api-new/database/migrations/013_create_client_tables.sql`
- `api-new/database/init/014_create_client_tables.sql`

**代码变更：**
```sql
-- 为 clients 表添加 location 字段
ALTER TABLE clients
ADD COLUMN IF NOT EXISTS location TEXT;

-- 添加注释
COMMENT ON COLUMN clients.location IS '客户地点';
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入相关方模块，点击新增客户
3. 填写客户信息（包括地点）
4. 确认保存成功，无报错

---

### 13. 供应商联系人表缺失修复

**问题现象：**
服务器环境新增供应商后，查询供应商联系人时控制台报错：
```
GET http://43.136.69.250/api/rest/v1/supplier_contacts?select=*&in.supplier_id=96b26a01-a243-484e-9d75-379039931593 500 (Internal Server Error)
```

**问题分析：**
1. **根本原因**：数据库中不存在 `supplier_contacts` 表
2. **前端代码**：`SupplierFormPage.tsx` 和 `SupplierList.tsx` 中都使用了 `supplier_contacts` 表来存储和查询供应商联系人
3. **错误触发**：当新增供应商后，前端尝试查询该供应商的联系人，但表不存在导致 500 错误
4. **结果**：供应商保存成功，但联系人信息无法存储和查询

**解决方案：**
1. **创建迁移文件**：添加 `supplier_contacts` 表到数据库
2. **更新初始化文件**：确保新环境创建表时包含 `supplier_contacts` 表

**修改文件：**
- `api-new/database/migrations/030_create_supplier_contacts.sql`（新增）
- `api-new/database/init/006_create_suppliers_and_risks.sql`

**表结构定义：**
```sql
CREATE TABLE IF NOT EXISTS supplier_contacts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    position TEXT,
    phone TEXT,
    email TEXT,
    is_primary BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入供应商管理页面
3. 添加新供应商并填写联系人信息
4. 保存成功后查看供应商详情，确认联系人信息显示正确
5. 检查控制台无 500 错误

---

### 14. 项目创建API路由404错误修复

**问题现象：**
服务器环境创建项目时，控制台报错：
```
POST http://43.136.69.250/api/api/projects 404 (Not Found)
创建项目失败: Error: 路由 POST /api/api/projects 不存在
```

**问题分析：**
1. **根本原因**：后端路由配置缺少 `/api/api/projects` 路径
2. **前端请求路径**：
   - `VITE_API_URL=http://43.136.69.250/api`
   - 前端请求 `/api/projects`
   - 完整URL：`http://43.136.69.250/api/api/projects`
3. **后端路由配置**：
   - `/api/projects` - 用于直接访问（开发环境）
   - `/api/auth/v1`、`/api/rest/v1` 等 - 用于Nginx代理
   - 缺少 `/api/api/projects` - 用于Nginx代理后的自定义API
4. **结果**：项目创建API返回 404 错误

**解决方案：**
在 `index.ts` 中添加带双 `/api` 前缀的自定义API路由配置：

```typescript
// 路由（带双 /api 前缀，兼容 Nginx 代理后的自定义 API）
app.use('/api/api/projects', projectsRouter);
app.use('/api/api/project-suppliers', projectSuppliersRouter);
app.use('/api/api/duplicate-check', duplicateCheckRouter);
```

**为什么不修改 VITE_API_URL？**
如果去掉 `/api` 后缀，会导致其他接口（auth、rest、storage、health）无法使用，因为这些接口的前端请求路径不带 `/api` 前缀，依赖 `VITE_API_URL` 提供。

**修改文件：**
- `api-new/src/index.ts`

**部署说明：**
需要重新编译并重启后端服务：
```bash
cd api-new
npm run build
npm start
```

**验证方式：**
1. 部署更新后的后端服务
2. 进入项目列表页面
3. 点击创建项目
4. 填写项目信息并提交
5. 确认项目创建成功，无 404 错误

---

### 15. 项目创建数据库字段缺失修复

**问题现象：**
服务器环境创建项目时，控制台报错：
```
POST http://43.136.69.250/api/api/projects 500 (Internal Server Error)
创建项目失败: Error: insert into "projects" (...) values (...) returning * - column "created_by" of relation "projects" does not exist
```

**问题分析：**
1. **根本原因**：`projects` 表缺少 `created_by` 字段
2. **后端代码**：`api-new/src/routes/projects.ts` 第72行在创建项目时尝试插入 `created_by` 字段
3. **数据库表**：`002_create_projects.sql` 中没有定义 `created_by` 字段
4. **结果**：SQL 插入语句执行失败，返回 500 错误

**解决方案：**
1. **创建迁移文件**：添加 `created_by` 字段到 `projects` 表
2. **更新初始化文件**：确保新环境创建表时包含 `created_by` 字段

**修改文件：**
- `api-new/database/migrations/031_add_projects_created_by.sql`（新增）
- `api-new/database/init/002_create_projects.sql`

**代码变更：**
```sql
-- 为 projects 表添加 created_by 字段
ALTER TABLE projects
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id);

-- 添加注释
COMMENT ON COLUMN projects.created_by IS '项目创建者ID';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入项目列表页面
3. 点击创建项目
4. 填写项目信息并提交
5. 确认项目创建成功，无 500 错误

---

### 16. 项目里程碑初始化数据库字段缺失修复

**问题现象：**
服务器环境创建项目时，项目创建成功但里程碑初始化失败，控制台报错：
```
项目创建警告: 项目创建成功，但里程碑初始化失败: insert into "project_milestones" (...) values (...) - column "created_by" of relation "project_milestones" does not exist
```

**问题分析：**
1. **根本原因**：`project_milestones` 表缺少 `created_by` 字段
2. **后端代码**：`projectInitService.ts` 在初始化项目里程碑时尝试插入 `created_by` 字段
3. **数据库表**：`003_create_milestones.sql` 中没有定义 `created_by` 字段
4. **结果**：里程碑初始化失败，但项目本身创建成功

**解决方案：**
1. **创建迁移文件**：添加 `created_by` 字段到 `project_milestones` 表
2. **更新初始化文件**：确保新环境创建表时包含 `created_by` 字段

**修改文件：**
- `api-new/database/migrations/032_add_project_milestones_created_by.sql`（新增）
- `api-new/database/init/003_create_milestones.sql`

**代码变更：**
```sql
-- 为 project_milestones 表添加 created_by 字段
ALTER TABLE project_milestones
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id);

-- 添加注释
COMMENT ON COLUMN project_milestones.created_by IS '里程碑创建者ID';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_project_milestones_created_by ON project_milestones(created_by);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入项目列表页面
3. 点击创建项目
4. 填写项目信息并提交
5. 确认项目创建成功，里程碑初始化也成功
6. 检查控制台无警告信息

---

### 17. 通知表字段缺失修复

**问题现象：**
服务器环境更新任务状态时，控制台报错：
```
POST http://43.136.69.250/api/rest/v1/notifications 500 (Internal Server Error)
[API] Insert error to notifications: Error: insert into "notifications" (...) values (...) - column "link" of relation "notifications" does not exist
```

**问题分析：**
1. **根本原因**：`notifications` 表缺少 `link` 和 `priority` 字段
2. **后端代码**：创建通知时尝试插入 `link` 和 `priority` 字段
3. **数据库表**：`007_create_files_and_notifications.sql` 中没有定义这些字段
4. **结果**：通知创建失败，返回 500 错误

**解决方案：**
1. **创建迁移文件**：添加 `link` 和 `priority` 字段到 `notifications` 表
2. **更新初始化文件**：确保新环境创建表时包含这些字段

**修改文件：**
- `api-new/database/migrations/033_add_notifications_fields.sql`（新增）
- `api-new/database/init/007_create_files_and_notifications.sql`

**代码变更：**
```sql
-- 为 notifications 表添加缺失字段
ALTER TABLE notifications
ADD COLUMN IF NOT EXISTS link TEXT,
ADD COLUMN IF NOT EXISTS priority TEXT DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high'));

-- 添加注释
COMMENT ON COLUMN notifications.link IS '通知链接，点击后跳转的URL';
COMMENT ON COLUMN notifications.priority IS '通知优先级：low-低, normal-普通, high-高';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_notifications_priority ON notifications(priority);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入任务列表页面
3. 更新任务状态
4. 确认通知创建成功，无 500 错误
5. 检查控制台无报错信息

---

### 18. 任务评论表字段缺失修复

**问题现象：**
服务器环境评论任务时，控制台报错：
```
POST http://43.136.69.250/api/rest/v1/task_comments 500 (Internal Server Error)
[API] Insert error to task_comments: Error: insert into "task_comments" (...) values (...) - column "created_by" of relation "task_comments" does not exist
```

**问题分析：**
1. **根本原因**：`task_comments` 表缺少 `created_by` 字段
2. **后端代码**：创建评论时尝试插入 `created_by` 字段
3. **数据库表**：`004_create_tasks.sql` 中只有 `user_id` 字段，没有 `created_by` 字段
4. **结果**：评论创建失败，返回 500 错误

**解决方案：**
1. **创建迁移文件**：添加 `created_by` 字段到 `task_comments` 表
2. **数据迁移**：将现有的 `user_id` 数据复制到 `created_by`
3. **更新初始化文件**：确保新环境创建表时包含 `created_by` 字段

**修改文件：**
- `api-new/database/migrations/034_add_task_comments_created_by.sql`（新增）
- `api-new/database/init/004_create_tasks.sql`

**代码变更：**
```sql
-- 为 task_comments 表添加 created_by 字段
ALTER TABLE task_comments
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id);

-- 将现有的 user_id 数据复制到 created_by
UPDATE task_comments SET created_by = user_id WHERE created_by IS NULL;

-- 添加注释
COMMENT ON COLUMN task_comments.created_by IS '评论创建者ID，与 user_id 保持一致';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_task_comments_created_by ON task_comments(created_by);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入任务详情页面
3. 添加任务评论
4. 确认评论创建成功，无 500 错误
5. 检查控制台无报错信息

---

### 19. 回款管理422错误修复

**问题现象：**
服务器环境项目管理的回款管理，点击回款报错：
```
POST http://43.136.69.250/api/api/projects/.../client-payments 422 (Unprocessable Entity)
项目未关联客户，无法创建回款记录
```

**问题分析：**
1. **根本原因**：`project_clients` 表缺少 `created_by` 字段
2. **后端代码**：`api-new/src/routes/projects.ts` 第85-90行创建项目时尝试插入 `created_by` 字段
   ```typescript
   await dbService.insert('project_clients', {
     project_id: projectId,
     client_id,
     role: 'primary',
     created_by: userId,  // 表中没有这个字段！
   });
   ```
3. **数据库表**：`014_create_client_tables.sql` 中没有定义 `created_by` 字段
4. **结果**：
   - 项目创建成功（因为错误被捕获，不阻断主流程）
   - 但项目-客户关联创建失败
   - 导致后续创建回款时找不到关联客户，返回 422 错误

**解决方案：**
1. **创建迁移文件**：添加 `created_by` 字段到 `project_clients` 表
2. **更新初始化文件**：确保新环境创建表时包含 `created_by` 字段

**修改文件：**
- `api-new/database/migrations/035_add_project_clients_created_by.sql`（新增）
- `api-new/database/init/014_create_client_tables.sql`

**代码变更：**
```sql
-- 为 project_clients 表添加 created_by 字段
ALTER TABLE project_clients
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id);

-- 添加注释
COMMENT ON COLUMN project_clients.created_by IS '项目-客户关联创建者ID';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_project_clients_created_by ON project_clients(created_by);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 创建新项目并关联客户
3. 进入回款管理页面
4. 点击创建回款记录
5. 确认回款创建成功

---

### 20. 项目经理无法调整供应商详情权限修复

**问题现象：**
服务器环境，项目的项目经理没有对项目内供应商的详情调整的权限。

**问题分析：**
1. **前端权限检查**：`SupplierDetailModal.tsx` 第423-432行的 `canEditModules` 函数只检查是否是项目成员
   ```typescript
   const canEditModules = async () => {
     if (!user) return false;
     const { data } = await api.db
       .from('project_members')
       .select('*')
       .eq('project_id', projectSupplier.project_id)
       .eq('user_id', user.id)
       .single();
     return !!data;
   };
   ```
2. **后端权限检查**：`projectSuppliers.ts` 第130-135行检查是否是管理员或项目经理
   ```typescript
   const isAdmin = userRole === 'admin';
   const isManager = project?.manager_id === userId;
   if (!isAdmin && !isManager) {
     throw new ValidationError('无权更新该供应商关联');
   }
   ```
3. **问题原因**：
   - 项目经理创建项目时，自动成为项目经理（`manager_id`）
   - 但项目经理不一定在 `project_members` 表中
   - 前端只检查 `project_members`，导致项目经理看不到编辑按钮
   - 后端检查 `manager_id`，权限判断不一致

**解决方案：**
修改前端 `canEditModules` 函数，与后端权限判断保持一致：

```typescript
const canEditModules = async () => {
  if (!user) return false;
  // 检查是否是项目经理
  const { data: project } = await api.db
    .from('projects')
    .select('manager_id')
    .eq('id', projectSupplier.project_id)
    .single();
  if (project?.manager_id === user.id) return true;
  // 检查是否是管理员
  if (user.role === 'admin') return true;
  // 检查是否是项目成员
  const { data } = await api.db
    .from('project_members')
    .select('*')
    .eq('project_id', projectSupplier.project_id)
    .eq('user_id', user.id)
    .single();
  return !!data;
};
```

**修改文件：**
- `src/pages/projects/components/SupplierDetailModal.tsx`

**部署说明：**
需要重新构建并部署前端：
```bash
./deploy/update/deploy.sh
```

**验证方式：**
1. 部署更新后的前端
2. 以项目经理身份登录
3. 进入项目详情页面
4. 打开供应商详情弹窗
5. 确认可以看到"调整"按钮
6. 点击调整按钮，确认可以修改供应商详情

---

### 21. 项目成员不显示项目经理修复

**问题现象：**
服务器环境创建项目后，项目详情的项目成员里没有显示项目经理。

**问题分析：**
1. **后端代码**：`api-new/src/routes/projects.ts` 第98-110行尝试将项目经理添加到 `project_members` 表
   ```typescript
   await dbService.insert('project_members', {
     project_id: projectId,
     user_id: userId,
     role: 'manager',
     created_by: userId,  // 表中没有这个字段！
   });
   ```
2. **数据库表**：`002_create_projects.sql` 中 `project_members` 表没有 `created_by` 字段
3. **结果**：
   - 插入 `project_members` 失败（因为缺少 `created_by` 字段）
   - 错误被捕获，不阻断主流程
   - 项目创建成功，但项目经理没有被添加到成员表
   - 项目详情页面查询成员时，找不到项目经理

**解决方案：**
1. **创建迁移文件**：添加 `created_by` 字段到 `project_members` 表
2. **更新初始化文件**：确保新环境创建表时包含 `created_by` 字段

**修改文件：**
- `api-new/database/migrations/036_add_project_members_created_by.sql`（新增）
- `api-new/database/init/002_create_projects.sql`

**代码变更：**
```sql
-- 为 project_members 表添加 created_by 字段
ALTER TABLE project_members
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id);

-- 添加注释
COMMENT ON COLUMN project_members.created_by IS '项目成员添加者ID';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_project_members_created_by ON project_members(created_by);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**注意**：执行迁移后，需要**重新创建项目**，因为之前创建的项目经理都没有被添加到成员表。

**验证方式：**
1. 执行迁移脚本后
2. 创建新项目
3. 进入项目详情页面
4. 查看项目成员列表
5. 确认项目经理显示在成员列表中

---

### 22. 供应商验收表字段缺失修复

**问题现象：**
服务器环境新增验收报错：
```
POST http://43.136.69.250/api/rest/v1/supplier_acceptances 500 (Internal Server Error)
[API] Insert error to supplier_acceptances: Error: insert into "supplier_acceptances" (...) values (...) - column "attachments" of relation "supplier_acceptances" does not exist
```

**问题分析：**
1. **根本原因**：`supplier_acceptances` 表缺少多个字段
2. **后端代码**：创建验收时尝试插入 `attachments`, `created_by`, `description`, `result` 字段
3. **数据库表**：`013_create_supplier_extensions.sql` 中没有定义这些字段
4. **缺失字段**：
   - `attachments` - 附件列表
   - `created_by` - 创建者ID
   - `description` - 验收描述
   - `result` - 验收结果
5. **结果**：SQL 插入语句执行失败，返回 500 错误

**解决方案：**
1. **创建迁移文件**：添加缺失字段到 `supplier_acceptances` 表
2. **更新初始化文件**：确保新环境创建表时包含这些字段

**修改文件：**
- `api-new/database/migrations/037_add_supplier_acceptances_fields.sql`（新增）
- `api-new/database/init/013_create_supplier_extensions.sql`

**代码变更：**
```sql
-- 为 supplier_acceptances 表添加缺失字段
ALTER TABLE supplier_acceptances
ADD COLUMN IF NOT EXISTS attachments JSONB DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES profiles(id),
ADD COLUMN IF NOT EXISTS description TEXT,
ADD COLUMN IF NOT EXISTS result TEXT CHECK (result IN ('passed', 'failed', 'pending'));

-- 添加注释
COMMENT ON COLUMN supplier_acceptances.attachments IS '验收附件列表';
COMMENT ON COLUMN supplier_acceptances.created_by IS '验收记录创建者ID';
COMMENT ON COLUMN supplier_acceptances.description IS '验收描述';
COMMENT ON COLUMN supplier_acceptances.result IS '验收结果：passed-通过, failed-不通过, pending-待定';

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_supplier_acceptances_created_by ON supplier_acceptances(created_by);
CREATE INDEX IF NOT EXISTS idx_supplier_acceptances_result ON supplier_acceptances(result);
```

**部署说明：**
需要在服务器环境执行迁移脚本：
```bash
cd api-new
npx knex migrate:latest
```

**验证方式：**
1. 执行迁移脚本后
2. 进入项目详情页面
3. 打开供应商管理
4. 点击新增验收
5. 填写验收信息并提交
6. 确认验收创建成功，无 500 错误

---

### 23. 功能模块进度拖动状态不自动跳转修复

**问题现象：**
服务器环境，项目管理详情的功能模块页，点击拉动功能模块的进度，模块的状态没有自动跳转。

**问题分析：**
1. **前端代码**：`FunctionalModules.tsx` 第636-668行的 `handleProgressChange` 函数中，进度更新时状态自动跳转的逻辑有问题
   ```typescript
   // Auto-update status based on progress
   if (newProgress === 100 && selectedModule.status !== 'completed') {
     updates.status = 'completed';
   } else if (newProgress > 0 && selectedModule.status === 'pending') {
     updates.status = 'in_progress';
   }
   ```
2. **问题原因**：
   - 当进度从0拖动到大于0时，检查的是 `status === 'pending'`
   - 但数据库中的初始状态是 `'not_started'` 而不是 `'pending'`
   - 导致状态无法自动从"未开始"跳转到"进行中"

**解决方案：**
修改状态判断条件，同时检查 `'not_started'` 和 `'pending'` 两种状态：

```typescript
// Auto-update status based on progress
if (newProgress === 100 && selectedModule.status !== 'completed') {
  updates.status = 'completed';
} else if (newProgress > 0 && (selectedModule.status === 'not_started' || selectedModule.status === 'pending')) {
  updates.status = 'in_progress';
}
```

**修改文件：**
- `src/pages/projects/tabs/FunctionalModules.tsx`

**部署说明：**
需要重新构建并部署前端：
```bash
./deploy/update/deploy.sh
```

**验证方式：**
1. 部署更新后的前端
2. 进入项目详情页面
3. 打开功能模块页
4. 选择一个状态为"未开始"的模块
5. 拖动进度条到大于0的值
6. 确认状态自动跳转为"进行中"
7. 拖动进度条到100%
8. 确认状态自动跳转为"已完成"

---

### 24. 任务状态改为进行中时默认进度调整

**问题现象：**
任务详情页，把任务状态改成进行中后，任务进度就直接 50%，这不合理。

**问题分析：**
1. **前端代码**：`TaskDetailPage.tsx` 第507-517行的 `getLatestProgress` 函数中，根据任务状态返回默认进度
   ```typescript
   switch (task?.status) {
     case 'done': return 100;
     case 'in_progress': return 50;  // 这里设置为50%
     case 'todo': return 0;
     default: return 0;
   }
   ```
2. **问题原因**：当任务状态改为"进行中"时，默认进度设置为50%，这不符合实际业务逻辑
3. **业务逻辑**：任务刚开始进行时，进度应该是从5%开始，而不是50%

**解决方案：**
将"进行中"状态的默认进度从50%改为5%：

```typescript
switch (task?.status) {
  case 'done': return 100;
  case 'in_progress': return 5;  // 改为5%
  case 'todo': return 0;
  default: return 0;
}
```

**修改文件：**
- `src/pages/tasks/TaskDetailPage.tsx`

**部署说明：**
需要重新构建并部署前端：
```bash
./deploy/update/deploy.sh
```

**验证方式：**
1. 部署更新后的前端
2. 进入任务详情页面
3. 将任务状态改为"进行中"
4. 确认任务进度显示为5%

---

## 明日计划

1. 继续迁移其他核心页面（如文档、风险等）
2. 在系统设置中添加主题切换预览功能
3. 测试验证主题切换时所有组件的响应

## 备注

- 所有主题化组件已创建完成并通过类型检查
- 登录页管理、系统设置、Dashboard、项目列表、任务列表、论坛页面、项目创建页面已完成迁移
- 项目列表页面布局问题已修复
- 项目创建查重功能已完成，使用主题化弹窗提示错误
- 弹窗组件已优化为层叠淡化毛玻璃效果
- 重置密码复制功能已修复，支持降级方案
- 开发服务器运行正常，可访问 http://localhost:5174/ 进行验证
- 详细设计文档见：`系统主题适配设计记录.md`
